---
title: Quickstart
description: Build your first hypergraph workflow in 5 minutes
---

Get hypergraph running with a simple RAG pipeline. No theory — just working code.

## Installation

<CodeGroup>
```bash uv
uv add git+https://github.com/gilad-rubin/hypergraph.git
```

```bash pip
pip install git+https://github.com/gilad-rubin/hypergraph.git
```
</CodeGroup>

<Note>
  Hypergraph is in alpha. The API may change between releases, but core features (nodes, graphs, runners, routing) are stable.
</Note>

## Build Your First Pipeline

<Steps>
  <Step title="Define your functions">
    Create three functions for a simple RAG workflow. Use the `@node` decorator and name the outputs:

    ```python
    from hypergraph import Graph, node, SyncRunner

    @node(output_name="embedding")
    def embed(text: str) -> list[float]:
        # Mock embedding for demo
        return [0.1, 0.2, 0.3]

    @node(output_name="docs")
    def retrieve(embedding: list[float]) -> list[str]:
        # Mock retrieval
        return ["Doc about RAG", "Doc about embeddings"]

    @node(output_name="answer")
    def generate(docs: list[str], query: str) -> str:
        # Mock generation
        context = "\n".join(docs)
        return f"Based on: {context}\nAnswer to '{query}'"
    ```
  </Step>

  <Step title="Connect them automatically">
    Hypergraph infers edges by matching output names to input parameters:

    ```python
    # Edges created automatically:
    # embed → retrieve (embedding connects them)
    # retrieve → generate (docs connects them)
    graph = Graph(nodes=[embed, retrieve, generate])
    ```

    No manual wiring needed — `embed` produces `embedding`, which `retrieve` accepts as a parameter.
  </Step>

  <Step title="Run the pipeline">
    Execute the graph with your inputs:

    ```python
    runner = SyncRunner()
    result = runner.run(graph, text="RAG tutorial", query="What is RAG?")

    print(result["answer"])
    # Based on: Doc about RAG
    # Doc about embeddings
    # Answer to 'What is RAG?'
    ```

    The runner manages execution order automatically based on dependencies.
  </Step>
</Steps>

## What Just Happened?

The graph connected your functions using **name-based dependency inference**:

```text
embed(text) → "embedding"
                  ↓
retrieve(embedding) → "docs"
                         ↓
generate(docs, query) → "answer"
```

When a function's parameter name matches another function's output name, hypergraph creates an edge automatically.

## Next Steps

<CardGroup cols={3}>
  <Card title="Core Concepts" icon="book" href="/core-concepts/nodes">
    Understand nodes, graphs, and runners
  </Card>
  
  <Card title="Simple Pipeline" icon="diagram-project" href="/patterns/simple-pipeline">
    Learn the DAG pattern in depth
  </Card>
  
  <Card title="RAG Example" icon="code" href="/examples/rag-pipeline">
    Build a real RAG pipeline with LLMs
  </Card>
</CardGroup>
